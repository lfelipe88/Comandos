
# 🧠 Principios SOLID en C# (.NET Core)

Los principios **SOLID** son una guía fundamental para escribir código limpio, mantenible y escalable. Son esenciales para cualquier desarrollador orientado a objetos. Aquí te los explicamos de forma sencilla, con ejemplos en C# y un toque divertido. 🚀

---

## 🟡 S - Single Responsibility Principle (SRP)
📌 *"Una clase debe tener una sola razón para cambiar."*  
Cada clase debe encargarse de una única funcionalidad.

```csharp
class Report {
    public string Title { get; set; }
    public string Content { get; set; }

    public void Generate() {
        // Generar el reporte
    }
}

class ReportPrinter {
    public void Print(Report report) {
        // Imprimir el reporte
    }
}
```

✅ **Separación de responsabilidades:** `Report` genera, `ReportPrinter` imprime.  
📋 **Paso a paso:** Identifica responsabilidades distintas y sepáralas en clases diferentes.

---

## 🔵 O - Open/Closed Principle (OCP)
📌 *"El código debe estar abierto para extensión, pero cerrado para modificación."*  
Puedes agregar funcionalidades sin modificar el código existente.

```csharp
abstract class Shape {
    public abstract double Area();
}

class Circle : Shape {
    public double Radius { get; set; }
    public override double Area() => Math.PI * Radius * Radius;
}

class Square : Shape {
    public double Side { get; set; }
    public override double Area() => Side * Side;
}
```

🧱 **Extiende sin tocar lo ya hecho.**  
📋 **Paso a paso:** Usa clases abstractas e interfaces para permitir extensiones.

---

## 🔴 L - Liskov Substitution Principle (LSP)
📌 *"Una subclase debe poder sustituir a su clase base sin alterar el comportamiento."*  

```csharp
class Bird {
    public virtual void Fly() => Console.WriteLine("Flying");
}

class Sparrow : Bird {
    public override void Fly() => Console.WriteLine("Sparrow flying");
}
```

✅ **`Sparrow` puede reemplazar a `Bird` sin errores.**  
📋 **Paso a paso:** Hereda solo cuando el comportamiento sea coherente con la clase base.

---

## 🟣 I - Interface Segregation Principle (ISP)
📌 *"No obligues a las clases a implementar métodos que no usan."*  

```csharp
interface IPrinter {
    void Print();
}

interface IScanner {
    void Scan();
}

class Printer : IPrinter {
    public void Print() => Console.WriteLine("Printing...");
}
```

✅ **Interfaces pequeñas y específicas.**  
📋 **Paso a paso:** Divide interfaces grandes en varias pequeñas.

---

## 🟢 D - Dependency Inversion Principle (DIP)
📌 *"Depende de abstracciones, no de implementaciones concretas."*  

```csharp
interface IMessageSender {
    void Send(string message);
}

class EmailSender : IMessageSender {
    public void Send(string message) => Console.WriteLine("Email: " + message);
}

class NotificationService {
    private readonly IMessageSender _sender;

    public NotificationService(IMessageSender sender) {
        _sender = sender;
    }

    public void Notify(string msg) => _sender.Send(msg);
}
```

✅ **Flexibilidad total usando interfaces.**  
📋 **Paso a paso:** Inyecta dependencias desde afuera y trabaja con interfaces.

---

## 🏁 Conclusión
Aplicar **SOLID** no solo mejora tu código, ¡también te hace un desarrollador más feliz y eficiente! 😄  
🔧 Mejora el mantenimiento, 📦 facilita las pruebas y 📈 permite escalar tu proyecto con confianza.

¡Feliz codificación! 🎉
