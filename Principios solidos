
# ğŸ§  Principios SOLID en C# (.NET Core) - Explicado con Ejemplos Comparativos

Los principios **SOLID** son cinco buenas prÃ¡cticas que todo desarrollador orientado a objetos deberÃ­a aplicar. Ayudan a crear cÃ³digo **mÃ¡s limpio**, **fÃ¡cil de mantener** y **escalable**.

Este README te mostrarÃ¡ quÃ© son, cÃ³mo aplicarlos con ejemplos **antes y despuÃ©s** de aplicar cada principio. Â¡Todo con estilo claro y amigable! ğŸ‰

---

## ğŸŸ¡ S - Single Responsibility Principle (SRP)
ğŸ“Œ *"Una clase debe tener una sola razÃ³n para cambiar."*  
Cada clase debe encargarse de **una sola cosa**.

### âŒ Sin aplicar SRP:
```csharp
// Esta clase tiene dos responsabilidades: generar e imprimir un reporte
class Report {
    public string Title { get; set; }
    public string Content { get; set; }

    public void Generate() {
        // Generar contenido del reporte
    }

    public void Print() {
        // Imprimir el reporte
    }
}
```

### âœ… Aplicando SRP:
```csharp
class Report {
    public string Title { get; set; }
    public string Content { get; set; }

    public void Generate() {
        // Solo genera el contenido
    }
}

class ReportPrinter {
    public void Print(Report report) {
        // Solo imprime el reporte
    }
}
```
ğŸ¯ **Ventaja:** Si cambia la lÃ³gica de impresiÃ³n, solo modificamos `ReportPrinter`, no `Report`.

---

## ğŸ”µ O - Open/Closed Principle (OCP)
ğŸ“Œ *"El cÃ³digo debe estar abierto para extensiÃ³n, pero cerrado para modificaciÃ³n."*

### âŒ Sin aplicar OCP:
```csharp
// Cada vez que se agrega una nueva forma, hay que modificar esta clase
class AreaCalculator {
    public double TotalArea(object[] shapes) {
        double area = 0;
        foreach (var shape in shapes) {
            if (shape is Circle c)
                area += Math.PI * c.Radius * c.Radius;
            else if (shape is Square s)
                area += s.Side * s.Side;
        }
        return area;
    }
}
```

### âœ… Aplicando OCP:
```csharp
abstract class Shape {
    public abstract double Area();
}

class Circle : Shape {
    public double Radius { get; set; }
    public override double Area() => Math.PI * Radius * Radius;
}

class Square : Shape {
    public double Side { get; set; }
    public override double Area() => Side * Side;
}

class AreaCalculator {
    public double TotalArea(Shape[] shapes) {
        return shapes.Sum(s => s.Area());
    }
}
```
ğŸ¯ **Ventaja:** Podemos agregar nuevas formas sin modificar `AreaCalculator`.

---

## ğŸ”´ L - Liskov Substitution Principle (LSP)
ğŸ“Œ *"Las subclases deben poder sustituir a sus clases base sin alterar el comportamiento del programa."*

### âŒ Sin aplicar LSP:
```csharp
// Penguin no puede volar, pero estamos obligando a que lo haga
class Bird {
    public virtual void Fly() => Console.WriteLine("Flying...");
}

class Penguin : Bird {
    public override void Fly() => throw new NotImplementedException();
}
```

### âœ… Aplicando LSP:
```csharp
interface IBird { }

interface IFlyingBird : IBird {
    void Fly();
}

class Sparrow : IFlyingBird {
    public void Fly() => Console.WriteLine("Sparrow flying...");
}

class Penguin : IBird {
    // No vuela, pero cumple con el contrato
}
```
ğŸ¯ **Ventaja:** Respetamos los contratos sin generar excepciones innecesarias.

---

## ğŸŸ£ I - Interface Segregation Principle (ISP)
ğŸ“Œ *"Los clientes no deben verse forzados a depender de interfaces que no utilizan."*

### âŒ Sin aplicar ISP:
```csharp
interface IMachine {
    void Print();
    void Scan();
    void Fax();
}

class OldPrinter : IMachine {
    public void Print() { }
    public void Scan() => throw new NotImplementedException();
    public void Fax() => throw new NotImplementedException();
}
```

### âœ… Aplicando ISP:
```csharp
interface IPrinter {
    void Print();
}

interface IScanner {
    void Scan();
}

class SimplePrinter : IPrinter {
    public void Print() => Console.WriteLine("Printing...");
}
```
ğŸ¯ **Ventaja:** Cada clase implementa solo lo que realmente necesita.

---

## ğŸŸ¢ D - Dependency Inversion Principle (DIP)
ğŸ“Œ *"Depende de abstracciones, no de implementaciones concretas."*

### âŒ Sin aplicar DIP:
```csharp
class EmailSender {
    public void Send(string message) => Console.WriteLine("Email: " + message);
}

class NotificationService {
    private EmailSender _sender = new EmailSender();

    public void Notify(string msg) => _sender.Send(msg);
}
```

### âœ… Aplicando DIP:
```csharp
interface IMessageSender {
    void Send(string message);
}

class EmailSender : IMessageSender {
    public void Send(string message) => Console.WriteLine("Email: " + message);
}

class NotificationService {
    private readonly IMessageSender _sender;

    public NotificationService(IMessageSender sender) {
        _sender = sender;
    }

    public void Notify(string msg) => _sender.Send(msg);
}
```
ğŸ¯ **Ventaja:** Podemos usar diferentes tipos de mensajes (Email, SMS, Push) sin modificar `NotificationService`.

---

## ğŸ ConclusiÃ³n

Aplicar **SOLID** no se trata de seguir reglas estrictas, sino de **escribir mejor cÃ³digo**. Te ayuda a:

- âœ¨ Mantenerlo limpio y comprensible
- ğŸ§ª Facilitar pruebas unitarias
- âš™ï¸ Escalar sin miedo
- ğŸ¤ Trabajar mejor en equipo

Â¡Empieza a aplicarlos desde hoy y verÃ¡s la diferencia! ğŸš€ğŸ’¡
