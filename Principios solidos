
# ğŸ§  Principios SOLID en C# (.NET Core)

Los principios **SOLID** son una guÃ­a fundamental para escribir cÃ³digo limpio, mantenible y escalable. Son esenciales para cualquier desarrollador orientado a objetos. AquÃ­ te los explicamos de forma sencilla, con ejemplos en C# y un toque divertido. ğŸš€

---

## ğŸŸ¡ S - Single Responsibility Principle (SRP)
ğŸ“Œ *"Una clase debe tener una sola razÃ³n para cambiar."*  
Cada clase debe encargarse de una Ãºnica funcionalidad.

```csharp
class Report {
    public string Title { get; set; }
    public string Content { get; set; }

    public void Generate() {
        // Generar el reporte
    }
}

class ReportPrinter {
    public void Print(Report report) {
        // Imprimir el reporte
    }
}
```

âœ… **SeparaciÃ³n de responsabilidades:** `Report` genera, `ReportPrinter` imprime.  
ğŸ“‹ **Paso a paso:** Identifica responsabilidades distintas y sepÃ¡ralas en clases diferentes.

---

## ğŸ”µ O - Open/Closed Principle (OCP)
ğŸ“Œ *"El cÃ³digo debe estar abierto para extensiÃ³n, pero cerrado para modificaciÃ³n."*  
Puedes agregar funcionalidades sin modificar el cÃ³digo existente.

```csharp
abstract class Shape {
    public abstract double Area();
}

class Circle : Shape {
    public double Radius { get; set; }
    public override double Area() => Math.PI * Radius * Radius;
}

class Square : Shape {
    public double Side { get; set; }
    public override double Area() => Side * Side;
}
```

ğŸ§± **Extiende sin tocar lo ya hecho.**  
ğŸ“‹ **Paso a paso:** Usa clases abstractas e interfaces para permitir extensiones.

---

## ğŸ”´ L - Liskov Substitution Principle (LSP)
ğŸ“Œ *"Una subclase debe poder sustituir a su clase base sin alterar el comportamiento."*  

```csharp
class Bird {
    public virtual void Fly() => Console.WriteLine("Flying");
}

class Sparrow : Bird {
    public override void Fly() => Console.WriteLine("Sparrow flying");
}
```

âœ… **`Sparrow` puede reemplazar a `Bird` sin errores.**  
ğŸ“‹ **Paso a paso:** Hereda solo cuando el comportamiento sea coherente con la clase base.

---

## ğŸŸ£ I - Interface Segregation Principle (ISP)
ğŸ“Œ *"No obligues a las clases a implementar mÃ©todos que no usan."*  

```csharp
interface IPrinter {
    void Print();
}

interface IScanner {
    void Scan();
}

class Printer : IPrinter {
    public void Print() => Console.WriteLine("Printing...");
}
```

âœ… **Interfaces pequeÃ±as y especÃ­ficas.**  
ğŸ“‹ **Paso a paso:** Divide interfaces grandes en varias pequeÃ±as.

---

## ğŸŸ¢ D - Dependency Inversion Principle (DIP)
ğŸ“Œ *"Depende de abstracciones, no de implementaciones concretas."*  

```csharp
interface IMessageSender {
    void Send(string message);
}

class EmailSender : IMessageSender {
    public void Send(string message) => Console.WriteLine("Email: " + message);
}

class NotificationService {
    private readonly IMessageSender _sender;

    public NotificationService(IMessageSender sender) {
        _sender = sender;
    }

    public void Notify(string msg) => _sender.Send(msg);
}
```

âœ… **Flexibilidad total usando interfaces.**  
ğŸ“‹ **Paso a paso:** Inyecta dependencias desde afuera y trabaja con interfaces.

---

## ğŸ ConclusiÃ³n
Aplicar **SOLID** no solo mejora tu cÃ³digo, Â¡tambiÃ©n te hace un desarrollador mÃ¡s feliz y eficiente! ğŸ˜„  
ğŸ”§ Mejora el mantenimiento, ğŸ“¦ facilita las pruebas y ğŸ“ˆ permite escalar tu proyecto con confianza.

Â¡Feliz codificaciÃ³n! ğŸ‰
